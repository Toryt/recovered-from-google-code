package org.toryt.util_I.collections.algebra;

import org.toryt.util_I.collections.algebra.AbstractAggregatorFactory.AbstractAggregator;
import org.toryt.util_I.collections.bigSet.algebra.ProductBigSet;
import org.toryt.util_I.collections.priorityList.algebra.BiProductPriorityList;


/**
 * <p>Since instances of {@link Aggregator} are stateful, we need
 *   a separate entity to hold the setup of the aggregators for
 *   a given product collection. {@link #create()} creates a fresh
 *   aggregator instance.</p>
 * <p>Implementations might benefit from {@link AbstractAggregatorFactory}.</p>
 *
 * @author Jan Dockx
 *
 * @invar getNrOfComponents() >= 0;
 * @invar getElementType() != null;
 * @invar new.getElementType() == getElementType();
 */
public interface AggregatorFactory {

  /* <section name="Meta Information"> */
  //------------------------------------------------------------------
  /** {@value} */
  public static final String CVS_REVISION = "$Revision$";
  /** {@value} */
  public static final String CVS_DATE = "$Date$";
  /** {@value} */
  public static final String CVS_STATE = "$State$";
  /** {@value} */
  public static final String CVS_TAG = "$Name$";
  /* </section> */

  /**
   * The type elements that will be generated by {@link Aggregator Aggregators}
   * generated by this instance.
   *
   * @basic
   */
  Class getElementType();

  /**
   * The number of components that {@link Aggregator Aggregators} generated
   * by this instance need and accept to generate a aggregation-instances.
   *
   * @basic
   */
  int getNrOfComponents();

  /**
   * Create a fresh {@link Aggregator} that generates instances of {@link #getElementType()}
   * based on {@link #getNrOfComponents()} component elements.
   *
   * @result AggregatorFactory.result == this;
   */
  Aggregator create();

  /**
   * <p>Instances are used to aggregate elements from different components
   *   in product-collections (see, e.g., {@link ProductBigSet} and
   *   {@link BiProductPriorityList}.</p>
   * <p>Component elements are set with an index. When component instances are
   *   set to your liking, call {@link #aggregate()} to generate a combination-instance,
   *   based on the current component elements.</p>
   * <p>An aggregator is stateful. We need a separate entity to hold the setup of
   *   the aggregators for a given product collection: {@link AggregatorFactory}.</p>
   * <p>Implementations might benefit from {@link AbstractAggregator}.</p>
   *
   * @invar getNrOfComponents() >= 0;
   * @invar getElementType() != null;
   * @invar new.getElementType() == getElementType();
   */
  public interface Aggregator {

    /**
     * Get the component instance for index <code>componentIndex</code>,
     * that would be used to build a combination-instance by {@link #aggregate()}.
     * If no component element was set by for index <code>componentIndex</code>
     * on this instance before this call, <code>null</code> is returned.
     *
     * @basic
     * @post componentIndex() < getNrOfComponents();
     * @throws IndexOutOfBoundsException
     *         (componentIndex < 0) || (componentIndex() >= getNrOfComponents());
     */
    Object getComponentElement(int componentIndex) throws IndexOutOfBoundsException;

    /**
     * Set the component instance for index <code>componentIndex</code>
     * to <code>componentElement</code>. This instance will be used to
     * build a combination-instance by {@link #aggregate()}.
     *
     * @pre componentIndex >= 0;
     * @post new.getComponentElement(componentIndex) == componentElement;
     * @post componentIndex() < getNrOfComponents();
     * @throws IndexOutOfBoundsException
     *         (componentIndex < 0) || (componentIndex() >= getNrOfComponents());
     * @throws IllegalArgumentException
     *         <code>componentElement</code> cannot be accepted as a component element
     *         for index <code>componentIndex</code> (e.g., because it is <code>null</code>,
     *         or it is not of the correct type).
     *
     */
    void setComponentElement(int componentIndex, Object componentElement)
        throws IndexOutOfBoundsException, IllegalArgumentException;

    /**
     * Generate a combination-instance, based on the component elements
     * {@link #getComponentElement(int)}.
     * The result might be <code>null</code> in some special cases.
     *
     * @result getElementType().isInstance(result);
     * @throws IllegalArgumentException
     *         We cannot create an aggregation given the current component
     *         elements.
     */
    Object aggregate() throws IllegalArgumentException;

  }

  /**
   * <p>{@link Aggregator} that is reversible, i.e., an object can
   *   be decomposed into its components.</p>
   */
  public interface ReversibleAggregator extends Aggregator {

    /**
     * <p>Decompose the given <code>object</code> into components.
     *   This is the reverse operation of {@link #aggregate()}.</p>
     * <p>The relationship must hold that
     *   after the execution of <code>decompose(generate())</code>, the components
     *   must be the same:</p>
     * <pre>
     * (forall int i; (i >= 0) && (i < getNrOfComponents());
     *   new{decompose(generate())}.getComponentElement(i).equals(getComponentElement(i)));
     * </pre>
     * <p>For any <code>object</code> of type {@link #getElementType()},
     *   <code>generate(decompose(object))</code> must result in a fresh instance
     *   <em>similar</em> to <code>object</code> (we would like to say
     *   <code>generate(decompose(o)).equals(object)</code>, but we do no
     *   want to demand that the {@link #equals(Object)} method of <code>object</code>
     *   must be overwritten.</p>
     *
     * @throws IllegalArgumentException
     *         object == null;
     * @throws IllegalArgumentException
     *         ! getElementType().isInstance(object);
     */
    void decompose(Object object) throws IllegalArgumentException;

  }

}