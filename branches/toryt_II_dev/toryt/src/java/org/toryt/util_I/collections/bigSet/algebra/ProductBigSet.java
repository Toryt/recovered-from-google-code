package org.toryt.util_I.collections.bigSet.algebra;


import java.math.BigInteger;
import java.util.Iterator;

import org.toryt.patterns_I.Assertion;
import org.toryt.patterns_I.Collections;
import org.toryt.util_I.annotations.vcs.CvsInfo;
import org.toryt.util_I.collections.algebra.Aggregator;
import org.toryt.util_I.collections.algebra.AggregatorFactory;
import org.toryt.util_I.collections.algebra.ObjectArrayAggregatorFactory;
import org.toryt.util_I.collections.algebra.ReversibleAggregator;
import org.toryt.util_I.collections.bigSet.BigSet;
import org.toryt.util_I.collections.bigSet.lockable.LockableBigSet;


/**
 * <p>A lazy big set, that is the cartesian product of all component
 *   BigSets. The elements of this BigSet elements are generated by an
 *   {@link Aggregator} created from the {@link #getAggregatorFactory()}.
 *   with 1 element per {@link #getComponents() component}.
 *   The default {@link AggregatorFactory} is a
 *   {@link ObjectArrayAggregatorFactory}.</p>
 * <p>If one of the {@link #getComponents()} is <code>null</code>,
 *   it behaves as an empty set, making this an empty set too.</p>
 *
 * @author Jan Dockx
 *
 * @invar ! isNullAllowed();
 * @invar getAggregatorFactory() != null;
 * @invar getAggregatorFactory().getNrOfComponents() == getComponents().length;
 */
@CvsInfo(revision = "$Revision$",
         date     = "$Date$",
         state    = "$State$",
         tag      = "$Name$")
public class ProductBigSet<_ResultElementType_>
    extends AbstractComponentBigSet<_ResultElementType_, Object> {

  /**
   * @pre components != null;
   * @pre (forall int i; (i >= 0) && (i < component.length);
   *        (component[i] != null) ? component[i].isLocked());
   * @pre  _ResultElementType_ == Object[];
   * @post ArrayUtils.isEquals(component, new.getComponents());
   * @post new.getAggregatorFactory() instanceof ObjectArrayAggregatorFactory;
   */
  @SuppressWarnings("unchecked") // see pre
  public ProductBigSet(LockableBigSet<?>... component) {
    this((AggregatorFactory<_ResultElementType_>)new ObjectArrayAggregatorFactory(component.length),
         component);
  }

  /**
   * @pre components != null;
   * @pre aggregatorFactory != null;
   * @pre (forall int i; (i >= 0) && (i < component.length);
   *        (component[i] != null) ? component[i].isLocked());
   * @pre aggregatorFactory.getNrOfComponents() == component.length;
   * @post ArrayUtils.isEquals(component, new.getComponents());
   * @post new.getAggregatorFactory() == aggregatorFactory;
   */
  public ProductBigSet(AggregatorFactory<? extends _ResultElementType_> aggregatorFactory,
                       LockableBigSet<?>... component) {
    super(false, calculateSize(component), component);
    assert aggregatorFactory != null; // bit late, I know
    assert aggregatorFactory.getNrOfComponents() == component.length;
    assert Collections.forAll(component,
                              new Assertion<LockableBigSet<?>>() {

                                    public boolean isTrueFor(LockableBigSet<?> o) {
                                      return (o != null) ? o.isLocked() : true;
                                    }

                                  });
    $aggregatorFactory = aggregatorFactory;
  }

  private static BigInteger calculateSize(LockableBigSet<?>[] components) {
    BigInteger result = BigInteger.ONE;
    for (LockableBigSet<?> lbs : components) {
      if (lbs == null) {
        return BigInteger.ZERO;
      }
      result = result.multiply(lbs.getBigSize());
    }
    return result;
  }

  /**
   * @basic
   */
  public final AggregatorFactory<? extends _ResultElementType_> getAggregatorFactory() {
    return $aggregatorFactory;
  }

  /**
   * @invar $aggregatorFactory != null;
   */
  private final AggregatorFactory<? extends _ResultElementType_> $aggregatorFactory;

  /**
   * @return (product int i; (i >=0 ) && (i < getComponents().length);
   *            getComponents()[i].getBigSize());
   *
  public final BigInteger getBigSize();
   */

  /**
   * This implementation is fast when
   * {@link #getAggregatorFactory()}.{@link AggregatorFactory#create() create()}
   * returns a {@link ReversibleAggregator}. If the aggretor is not reversible,
   * this method might be intolerably slow, since we simply iterate over this
   * {@link BigSet}.
   */
  @Override
  public final boolean contains(final Object o) throws ClassCastException {
    if (o == null) {
      return false;
    }
    @SuppressWarnings("unchecked") _ResultElementType_ object = (_ResultElementType_)o;
      // this ClassCastException should not be caught, but just thrown
    LockableBigSet<?>[] components = getComponents();
    try {
      final ReversibleAggregator<? extends _ResultElementType_> aggregator =
          (ReversibleAggregator<? extends _ResultElementType_>)$aggregatorFactory.create();
      // ClassCastException possible; this makes a performant implementation possible
      aggregator.decompose(object); // IllegalArgumentException
      return Collections.forAll(components,
                                new Assertion<LockableBigSet<?>>() {

                                      private int i = -1;

                                      public boolean isTrueFor(LockableBigSet<?> lbs) {
                                        i++;
                                        return (lbs != null) &&
                                               lbs.contains(aggregator.getComponentElement(i));
                                      }

                                    });
    }
    catch (NullPointerException npExc) {
      /* can't decompose, and that should have been possible
       * Cannot throw an exception, because contract says that is for
       * null and wrong type, but type is ok (see above). So: false.
       */
      return false;
    }
    catch (ClassCastException ccExc) {
      /* less performant, possibly impossibly slow implementation, because
         elements cannot be decomposed. */
      return Collections.exists(this,
                                new Assertion<_ResultElementType_>() {

                                      public boolean isTrueFor(_ResultElementType_ aggregated) {
                                        assert o != null;
                                        return o.equals(aggregated);
                                      }

                                    });
    }
  }

  /**
   * @return (exists int i; (i > 0) && (i < getComponents().length);
   *            (getComponents()[i] == null) || getComponents()[i].isEmpty());
   */
  public final boolean isEmpty() {
    return Collections.exists(getComponents(),
                              new Assertion<LockableBigSet<?>>() {

                                    public boolean isTrueFor(LockableBigSet<?> o) {
                                      return (o == null) || o.isEmpty();
                                    }

                                  });
  }

  public Iterator<_ResultElementType_> iterator() {
    return new AbstractLockedCollectionIterator() {

      private final LockableBigSet<?>[] $components = getComponents();

      private final int dim = $components.length;

      private final Iterator<?>[] $iterators = new Iterator<?>[dim];

      {
        for (int i = 0; i < dim; i++) {
          if ($components[i] != null) {
            $iterators[i] = $components[i].iterator();
          }
        }
      }

      /**
       * Is null if there is no next
       */
      private Aggregator<? extends _ResultElementType_> $aggregator = $aggregatorFactory.create();

      {
        for (int j = dim - 1; j >= 0; j--) {
          if (($iterators[j] == null) || (! $iterators[j].hasNext())) {
            // we have an empty component
            $aggregator = null;
            assert isEmpty();
            assert ! hasNext();
            break;
          }
          $aggregator.setComponentElement(j, $iterators[j].next());
        }
      }

      private void prepareNext() {
        assert Collections.forAll($components,
                                  new Assertion<LockableBigSet<?>>() {
                                    public boolean isTrueFor(LockableBigSet<?> o) {
                                      return o != null;
                                    }
                                  });
        int i = dim - 1;
        boolean canProceed = false;
        while ((! canProceed) && (i >= 0)) {
          if (! $iterators[i].hasNext()) {
            $iterators[i] = $components[i].iterator();
            i--;
          }
          else {
            canProceed = true;
            // iterator at index i is first not reset
          }
        }
        if (! canProceed) {
          // if canProceed is still false; we are at the end
          $aggregator = null;
        }
        else {
          // take next at index i, and first elements at later indices
          for (int j = i; j < dim; j++) {
            $aggregator.setComponentElement(j, $iterators[j].next());
          }
        }
      }

      public final boolean hasNext() {
        return $aggregator != null;
      }

      public final _ResultElementType_ next() {
        _ResultElementType_ result = $aggregator.aggregate();
          // throws IllegalArgumentException; if it does
        prepareNext();
        return result;
      }

    };
  }

}