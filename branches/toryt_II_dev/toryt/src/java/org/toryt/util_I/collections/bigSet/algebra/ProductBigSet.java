package org.toryt.util_I.collections.bigSet.algebra;


import java.math.BigInteger;
import java.util.Iterator;

import org.toryt.patterns_I.Assertion;
import org.toryt.patterns_I.Collections;
import org.toryt.util_I.collections.algebra.AggregatorFactory;
import org.toryt.util_I.collections.algebra.ObjectArrayAggregatorFactory;
import org.toryt.util_I.collections.algebra.AggregatorFactory.Aggregator;
import org.toryt.util_I.collections.algebra.AggregatorFactory.ReversibleAggregator;
import org.toryt.util_I.collections.bigSet.BigSet;
import org.toryt.util_I.collections.bigSet.lockable.LockableBigSet;


/**
 * <p>A lazy big set, that is the cartesian product of all component
 *   BigSets. The elements of this BigSet elements are generated by an
 *   {@link Aggregator} created from the {@link #getAggregatorFactory()}.
 *   with 1 element per {@link #getComponents() component}.
 *   The default {@link AggregatorFactory} is a
 *   {@link ObjectArrayAggregatorFactory}.</p>
 * <p>If one of the {@link #getComponents()} is <code>null</code>,
 *   it behaves as an empty set, making this an empty set too.</p>
 *
 * @author Jan Dockx
 *
 * @invar (forall int i; (i >= 0) && (i < getComponents().length);
 *          getElementType().getComponentType().
 *              isAssignableFrom(getComponents()[i].getElementType()));
 * @invar ! isNullAllowed();
 * @invar getAggregatorFactory() != null;
 * @invar getElementType() == getAggregatorFactory().getElementType();
 */
public class ProductBigSet extends AbstractComponentBigSet {

  /* <section name="Meta Information"> */
  //------------------------------------------------------------------
  /** {@value} */
  public static final String CVS_REVISION = "$Revision$";
  /** {@value} */
  public static final String CVS_DATE = "$Date$";
  /** {@value} */
  public static final String CVS_STATE = "$State$";
  /** {@value} */
  public static final String CVS_TAG = "$Name$";
  /* </section> */

  /**
   * @pre elementType != null;
   * @pre components != null;
   * @pre (forall int i; (i >= 0) && (i < components.length);
   *        (components[i] != null) ? components[i].isLocked());
   * @pre (forall int i; (i >= 0) && (i < components.length);
   *        (components[i] != null) ?
   *          getElementType().getComponentType().
   *            isAssignableFrom(components[i].getElementType()));
   * @pre elementType.getComponentType() != null;
   * @post ArrayUtils.isEquals(components, new.getComponents());
   * @post new.getAggregatorFactory() instanceof ObjectArrayAggregatorFactory;
   */
  public ProductBigSet(Class elementType, LockableBigSet[] components) {
    this(new ObjectArrayAggregatorFactory(elementType.getComponentType(), components.length), components);
  }

  /**
   * @pre components != null;
   * @pre aggregatorFactory != null;
   * @pre (forall int i; (i >= 0) && (i < components.length);
   *        (components[i] != null) ? components[i].isLocked());
   * @post ArrayUtils.isEquals(components, new.getComponents());
   * @post new.getAggregatorFactory() == aggregatorFactory;
   */
  public ProductBigSet(AggregatorFactory aggregatorFactory, LockableBigSet[] components) {
    super(aggregatorFactory.getElementType(), false, calculateSize(components), components);
    assert aggregatorFactory != null; // bit late, I know
    assert Collections.forAll(components,
                              new Assertion() {

                                    public boolean isTrueFor(Object o) {
                                      return (o != null) ?
                                               ((LockableBigSet)o).isLocked() :
                                               true;
                                    }

                                  });
    $aggregatorFactory = aggregatorFactory;
  }

  private static BigInteger calculateSize(LockableBigSet[] components) {
    BigInteger result = BigInteger.ONE;
    for (int i = 0; i < components.length; i++) {
      if (components[i] == null) {
        return BigInteger.ZERO;
      }
      result = result.multiply(components[i].getBigSize());
    }
    return result;
  }

  /**
   * @basic
   */
  public final AggregatorFactory getAggregatorFactory() {
    return $aggregatorFactory;
  }

  /**
   * @invar $aggregatorFactory != null;
   */
  private final AggregatorFactory $aggregatorFactory;

  /**
   * @return (product int i; (i >=0 ) && (i < getComponents().length);
   *            getComponents()[i].getBigSize());
   *
  public final BigInteger getBigSize();
   */

  /**
   * This implementation is fast when
   * {@link #getAggregatorFactory()}.{@link AggregatorFactory#create() create()}
   * returns a {@link ReversibleAggregator}. If the aggretor is not reversible,
   * this method might be intolerably slow, since we simply iterate over this
   * {@link BigSet}.
   */
  public final boolean contains(final Object o) throws ClassCastException {
    if (o == null) {
      return false;
    }
    if (! getElementType().isInstance(o)) {
      return false;
    }
    LockableBigSet[] components = getComponents();
    try {
      final ReversibleAggregator aggregator = (ReversibleAggregator)$aggregatorFactory.create();
      // ClassCastException possible; this makes a performant implementation possible
      if ($aggregatorFactory.getNrOfComponents() != components.length) {
        return false;
      }
      aggregator.decompose(o);
      return Collections.forAll(components, new Assertion() {

                private int i = -1;

                public boolean isTrueFor(Object lbs) {
                  i++;
                  return (lbs != null) &&
                         ((LockableBigSet)lbs).contains(aggregator.getComponentElement(i));
                }

              });
    }
    catch (ClassCastException ccExc) {
      /* less performant, possibly impossibly slow implementation, because
         elements cannot be decomposed. */
      return Collections.exists(this, new Assertion() {

                public boolean isTrueFor(Object aggregated) {
                  assert o != null;
                  return o.equals(aggregated);
                }

              });
    }
  }

  /**
   * @return (exists int i; (i > 0) && (i < getComponents().length);
   *            (getComponents()[i] == null) || getComponents()[i].isEmpty());
   */
  public final boolean isEmpty() {
    return Collections.exists(getComponents(),
                              new Assertion() {

                                    public boolean isTrueFor(Object o) {
                                      return (o == null) ||
                                             ((LockableBigSet)o).isEmpty();
                                    }

                                  });
  }

  public Iterator iterator() {
    return new AbstractLockedCollectionIterator() {

      private final LockableBigSet[] $components = getComponents();

      private final int dim = $components.length;

      private final Iterator[] $iterators = new Iterator[dim];

      {
        for (int i = 0; i < dim; i++) {
          if ($components[i] != null) {
            $iterators[i] = $components[i].iterator();
          }
        }
      }

      /**
       * Is null if there is no next
       */
      private Aggregator $aggregator = $aggregatorFactory.create();

      {
        for (int j = dim - 1; j >= 0; j--) {
          if (($iterators[j] == null) || (! $iterators[j].hasNext())) {
            // we have an empty component
            $aggregator = null;
            assert isEmpty();
            assert ! hasNext();
            break;
          }
          $aggregator.setComponentElement(j, $iterators[j].next());
        }
      }

      private void prepareNext() {
        assert Collections.forAll($components,
                                  new Assertion() {
                                    public boolean isTrueFor(Object o) {
                                      return o != null;
                                    }
                                  });
        int i = dim - 1;
        boolean canProceed = false;
        while ((! canProceed) && (i >= 0)) {
          if (! $iterators[i].hasNext()) {
            $iterators[i] = $components[i].iterator();
            i--;
          }
          else {
            canProceed = true;
            // iterator at index i is first not reset
          }
        }
        if (! canProceed) {
          // if canProceed is still false; we are at the end
          $aggregator = null;
        }
        else {
          // take next at index i, and first elements at later indices
          for (int j = i; j < dim; j++) {
            $aggregator.setComponentElement(j, $iterators[j].next());
          }
        }
      }

      public final boolean hasNext() {
        return $aggregator != null;
      }

      public final Object next() {
        Object result = $aggregator.aggregate();
        prepareNext();
        return result;
      }

    };
  }

}